# IO流

字节流：二进制方式，用来处理单个字节

字符流：字符流用来处理文本文件。

**字节是给计算机看的，字符才是给人看的**

字节输入输出流：

```java
InputStream input = new FileInputStream("file.txt");
// 新建一个 BufferedInputStream 对象
BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("input.txt"));
// 读取文件的内容并复制到 String 对象中
String result = new String(bufferedInputStream.readAllBytes());
System.out.println(result);

```

字符输入输出流

```java
FileReader
```



字节缓冲输入输出流

IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。

字节缓冲流这里采用了装饰器模式来增强 `InputStream` 和`OutputStream`子类对象的功能。



## 装饰器模式

装饰器模式可以在不改变原有对象下拓展其功能

装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。

装饰器类需要跟**原始类继承相同的抽象类或者实现相同的接口**。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 `InputStream` 和`OutputStream`。

**装饰器模式** 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。

## 适配器模式

**适配器（Adapter Pattern）模式** 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。

主要分为类适配器模式和对象适配器模式

## 工厂模式

工厂模式用于创建对象。针对接口编程，不要对实现编程

## 观察者模式

观察者模式又名发布-订阅模式。

定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。



## 单例模式

单例模式是一种软件设计模式，目的是确保一个类只有一个实例，并提供一个全局访问点来获取这个实例，这样做可以节省系统资源，并且保证某些类在系统中只有一个实例。

饿汉式：类加载就会导致该单例对象创建

懒汉式：类加载不会导致该实例对象创建，而是首次使用该对象时被创建。

```java

```



# IO模型



计算机结构：运算器()，存储器(内存)，控制器()，输入、输出。（控制器和运算器往往合称为CPU）

常见的IO模型

## BIO(Blocking I/O) 

同步阻塞IO模型。同步阻塞IO模型中，应用程序发起read调用后，会一直阻塞，直到内核把数据拷贝到用户空间。传统的BIO模型无法应对高并发量。

## *NIO(Non-blocking IO) 

一个I/O模型，包含三个组件：缓冲buffer、通道channel、选择器selector

同步非阻塞IO模型。它是支持面向缓冲的，基于通道的IO操作方法。对于高负载、高并发的应用，应使用NIO。

可以看作是I/O多路复用模型。

**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**

Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

![image-20240415105745146](C:\Users\wilzsn\AppData\Roaming\Typora\typora-user-images\image-20240415105745146.png)

![image-20240415105839427](C:\Users\wilzsn\AppData\Roaming\Typora\typora-user-images\image-20240415105839427.png)



## AIO （Async IO）

NIO的改进版，它是异步IO模型

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。




自我介绍

## 平时有什么爱好

## 数据结构里面堆和栈的区别

栈：一种特殊的线性结构，“先进后出”。

堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值纵使不大于或不小于其父节点的值的完全二叉树被称为堆。

## 操作系统里面堆和栈的区别

栈主要用来存放局部变量

- 申请方式不同，栈是由系统自动分配的，堆是要有程序员自己申请和释放。
- 申请大小限制不同：栈顶和栈底是之前预设好的，栈是由栈底扩展，大小固定。堆的大小不固定，可以灵活调整。
- 申请效率不同：栈是由系统分配的，速度较快，且没有碎片。堆是由程序员自己分配的，速度慢，且会出现碎片。

## 假设用C++new一个数组，它的实例是存在堆上还是在栈上的？

```c++
int main() {
    // 1. 普通的定义局部变量
    Corrdinate coord[3]; //这种是存放在栈上的
    Cooidinate *p = new Coordinate[3]; // 这种是存放在堆上的
}
```



## 介绍一下指针和引用

- 指针是一个变量，存储的是地址，引用是原变量的别名

- 指针可以指向null，引用不能为null且在定义时必须初始化。

- 指针可以为多级，引用只能为一级。

- 指针在初始化之后可以改变指向，但是引用在初始化之后不能改变纸箱。

  

## 写一个C++的函数，a(int b)，形参有时候传指针，有时候传引用，什么情况传指针，传引用？

1. 需要返回函数内局部变量的内存的时候使用指针。使用指针传参需要开辟内存，返回局部变量的引用是没有意义的。
2. 需要修改指针指向的传指针，引用不能改变指向。
3. 对栈空间大小比较敏感的时候（比如递归）需要使用引用。使用引用传递不需要创建临时变量，开销要更小。
4. 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。

## 为什么大的数据结构要传引用？

因为类对象作为参数传递的时候是值传递，所以需要调用拷贝函数，传引用的话不需要额外的开销

## 指针不同操作系统的大小？在32位和64位？

32位4字节，64位8字节。

## 指针在4字节和8字节存储有什么特别的吗？还是说只是内存地址？



## 写一个C++程序，从源代码到直接运行，需要经过什么阶段？

预编译——编译——汇编——链接

## 常量表达式，常量的赋值，在哪个阶段转换成具体的结果的？是在编译期还是在运行期？

const来描述常量，一般描述的是**运行时常量**，具有运行时数据的不可更改性。

C++11中通过constexpr，即常量表达式，编译器可以在**编译时期**对表达式进行值计算

## 数组，双向链表的区别

## 链表插入删除是怎么实现的？

## 面向对象的三大特性

封装、继承、多态

## 在开发过的项目，有没有基于面向对象去设计的案例？类或接口是怎么设计？

## Java 抽象类和interface

抽象类是对一个事物的抽象，即对类抽象，而接口是对方法进行抽象。

```java
class ClassName implements interface1 {
    // 要让一个类遵循某组特地的接口需要使用implements关键字
}
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
```

1.语法层面上的区别

　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

## 为什么要有抽象类这种设计？

抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象

## 装饰器模式





## 深浅拷贝，什么时候要用到深浅拷贝

浅拷贝：是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会导致原始对象中的对应字段也发生变化。

深拷贝：是创建一个新的和原始字段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字段发生改变，不会引起原始对象中的字段发生改变。

- 深拷贝：
  - 当需要复制一个对象，并且**不希望修改原始对象**时，使用深拷贝。
  - 当需要在**不同的上下文中使用相同的对象**时，使用深拷贝。
  - 当需要在**多个线程中使用相同的对象**时，使用深拷贝。
  - 当需要在**不同的进程中使用相同的对象**时，使用深拷贝。
  - 当需要在**不同的系统之间传递对象**时，使用深拷贝。
  - 当一个类**含有指针或引用时，通常需要使用深拷贝**，以避免共享同一份数据。
- 浅拷贝：
  - 当只需要复制一个对象的引用，而不关心其内部对象的变化时，使用浅拷贝。
  - 对于遍历、slice、concat、ES6扩展运算符(...)等操作，如果只涉及一层拷贝，可以视为浅拷贝。

## 了解哪些常用的http header，响应头字段

请求包：

浏览器能接受的Content-type，三四两行则是语言和编码信息，第五行显示出本机的相关系信息

Accept-Language

Accept-Encoding

Connection

响应头：

````htt
HTTP/1.1 200 OK
Server: Microsoft-IIS/5.1 // 服务器使用的web服务器软件
X-Powered-By: ASP.NET
Date: Fri, 03 Mar 2006 06:34:03 GMT // 处理此请求的时间
Content-Type: text/html  // 所返回信息的content-type
Accept-Ranges: bytes  // 它是由服务器端发送给客户端的，用来告诉客户端：“我可以处理范围请求哦
Last-Modified: Fri, 03 Mar 2006 06:33:18 GMT
ETag: "5ca4f75b8c3ec61:9ee"
Content-Length: 37  // 消息体的长度
````



## 了解过last_motified字段

Last-Modified响应头字段是服务器告知浏览器资源的最后修改时间。当浏览器请求某个资源时，服务器会将该资源的最后修改时间包含在Last-Modified头字段中。浏览器可以使用这个信息来判断是否需要重新请求该资源，以减少无效的资源传输。

## http头部的协议，讲一下1.x和2.x的不同？

**多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。

**二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。

**头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。

**服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

## TCP可靠传输怎么实现？

1. 基于数据块传输，
2. 对失序数据包重新排序以及去重：TCP根据序列号来对接收到的数据根据序列号进行排序，并且去掉重复序列号的数据就可以实现数据包去重
3. 校验和：TCP将保持它首部和数据的校验和。目的是检测数据在传输过程中的任何变化。如果出现差错，TCP将丢弃这个报文段和不确认收到此报文段
4. 重传机制：通过ACK确认应答包来实现重传
5. 流量控制(接收方)：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。
6. 拥塞控制(发送方)：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。

## 有没有用网络协议分析工具分析过请求？

wireshark

## 在浏览器输网址

## 客户端接收到返回的响应体，到用户真正看到内容，这里面有什么过程？

## 多线程和多进程有什么区别？

多进程和多线程的主要区别是：1、线程是进程的子集，一个进程可能由多个线程组成；2、多进程的数据是分开的，共享复杂，需要用ipc，但同步简单；3、多线程共享进程数据，共享简单，但同步复杂。

**多进程**：同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程，也称多任务。现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。

**多线程**：线程是一个轻量级的子进程，是最小的处理单元；是一个单独的执行路径。可以说：线程是进程的子集（部分），一个进程可能由多个线程组成。 线程是独立的。如果在一个线程中发生异常，则不会影响其他线程。它使用共享内存区域。多线程是一种执行模型，它允许多个线程存在于进程的上下文中，以便它们独立执行但共享其进程资源。

| 维度           | 多进程                                                       | 多线程                                 | 总结     |
| -------------- | ------------------------------------------------------------ | -------------------------------------- | -------- |
| 数据共享、同步 | 数据是分开的，共享复杂，需要用IPC（进程通信）；同步简单      | 多线程共享进程数据，共享简单；同步复杂 | 各有优势 |
| 内存、CPU      | 占用内存多，切换复杂，CPU利用率低                            | 占用内存少，切换简单，CPU利用率高      | 线程占优 |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                                   | 创建销毁、切换简单，速度快             | 线程占优 |
| 编程调试       | 编程简单，调试简单                                           | 编程复杂，调试复杂                     | 进程占优 |
| 可靠性         | 进程间不会相互影响                                           | 一个线程挂掉将导致整个进程挂掉         | 进程占优 |
| 分布式         | 适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布                         | 线程占优 |

## 为什么要有多线程，什么东西都放到一个线程里面不行吗？

1. 解决阻塞：提高`单进程`利用 [CPU](https://so.csdn.net/so/search?q=CPU&spm=1001.2101.3001.7020) 和 IO 系统的效率

2. ### 处理器上的核心数量越来越多，为了利用好`处理器上的多个核心`

3. ### 更快的响应时间

## io密集型的线程池，怎么理解这个类型？

io密集型的线程池：这类任务在执行过程中大部分时间都在等待输入输出操作，如文件读写，网络通讯等。对于io密集型任务，线程池的大小可以设置为CPU核心数的两倍(2N)，这样可以有效地利用CPU资源，同时提高IO操作的并发性。

计算密集型的线程池：这类任务主要消耗CPU资源，涉及大量的计算操作，如算法逻辑、数学计算等。对于计算密集型的任务，线程池的大小通常设置为CPU核心数加一（N+1）。这样可以有效地利用CPU资源，同时避免过多的线程导致上下文切换开销过大。

## 为什么要有两种线程池，它们之间有什么区别吗

## sql里面有 inner join，outer join? 怎么用的

```mysql
select * from table1 inner join table2 on tabel1.fileid = table2.fileid;
```

inner join 内连接 组合两个表中的记录，只要在公共字段之中有相符的值。INNER JOIN关键字在表中存在至少一个匹配时返回行。如果“Persons”中的行在“Orders”中没有匹配，就不会列出这些行。

outer join 外连接  外连接不同于内连接的一个性质：**外连接查询与表的顺序有关**

outer join 包含left join，right join

left join 左连接接收左表的所有行，并用这些行与右表进行匹配

right join右连接则是接收右表的所有行，并用这些行与左边连接

full join 全连接列出所有的人，哪怕是空值

**外连接一定会提供数据行，无论是否在另一个表中找出相匹配的行。**

## 死锁怎么理解，怎么防止死锁？

**互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。

**占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。

**非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。

**循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，……，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

## 写代码的时候遇到死锁？

## 实习的项目，大概是什么角色，以及做什么工作？

## 遇到最困难的点，解决掉的？

## 







